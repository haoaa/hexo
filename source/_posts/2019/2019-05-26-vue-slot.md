---
title: vue-slot
date: 2019-05-26 11:04:16
categories: vue slot
tags: vue slot
---

## 普通slot
- 父组件update的时候已经创建了vnode, 子组件render的时候直接从$slot返回对应的vnode

### 父组件parse 阶段
- 添加属性slot=slottarget, gendata生成对应字符串
- compile完 render, 创建子组件vnode后, 开始渲染子组件

```js
function processElement (
  element,
  options
) {
  processSlotContent(element);
  processSlotOutlet(element);
  processAttrs(element);
  return element
}
```
```js
// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }
}

```
<!--more-->

### genData 阶段
- 添加代码`"slot:" + (el.slotTarget) + ",`到render字符串中

```js

function genData$2 (el, state) {
  var data = '{';

  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
}

with(this){
  return _c('div',
    [_c('app-layout',
      [_c('h1',{attrs:{"slot":"header"},slot:"header"},
         [_v(_s(title))]),
       _c('p',[_v(_s(msg))]),
       _c('p',{attrs:{"slot":"footer"},slot:"footer"},
         [_v(_s(desc))]
         )
       ])
     ],
   1)}
```

### 子组件(compile) parse和gencode阶段
- 设置了$slots=> $mount -> compile
- slot节点添加slotName属性
- 通过_t生成vnode(renderSlot)

```js
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
  }
}
```

```js
// gencode
function genElement (el, state) {
  if (el.tag === 'slot') {
    return genSlot(el, state)
  }
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state); // slot包裹子节点
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}
// _t("header", children, attrs)

// 最终code
with(this) {
  return _c('div',{
    staticClass:"container"
    },[
      _c('header',[_t("header")],2),
      _c('main',[_t("default",[_v("默认内容")])],2),
      _c('footer',[_t("footer")],2)
      ]
   )
}
```

### 运行时实现(子组件)
- 普通slot渲染时, 通过$slot返回父组件传过来的children vnode.
- vnode已经通过

```js
// _t方法
function renderSlot : vnode(
  name,
  fallback, // slot包裹内容
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name]; // scope-slot的render方法
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback; // 默认内容
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}
```
- 2.6里slot和scope slot统一到scope slot, 优先从$scopedSlots获取

```js
Vue.prototype._render = function () { // 子组件render
  var vm = this;
  var ref = vm.$options;
  var render = ref.render;
  var _parentVnode = ref._parentVnode;

  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots( // $scopedSlots 来源
      _parentVnode.data.scopedSlots,
      vm.$slots, // 兼容2.5
      vm.$scopedSlots
    );
  }
}
function normalizeScopedSlots (
  slots, // 原父组件scope slot
  normalSlots, // $slots
  prevSlots // 反复刷新
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2); // 代理了vnode
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}
```

### $slots来源
- 父组件调用$mount=>编译=>调用_render生成vnode, 生成app-layout的vnode时里面的内容作为children传入
- 创建占位符节点后, patch vnode. 
- createChildren =>  componentVNodeHooks => createComponentInstanceForVnode=> 子组件new vue
  - 子组件流程: init => initRender => resolveSlots

#### 父组件 
```js
Vue.prototype._render = function () {
  var ref = vm.$options;
  var render = ref.render;
  var _parentVnode = ref._parentVnode;
  if (_parentVnode) {
    vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject; // 子组件获取父组件scopedSlots
  }
  vnode = render.call(vm._renderProxy, vm.$createElement);
  // _c('app-layout',...) createElement  
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  vnode = createComponent(Ctor, data, context, children, tag);
}

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
}


function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    createElm(vnode, insertedVnodeQueue, parentElm, refElm); 

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
```

#### 子组件
- 流程: init => initRender => resolveSlots

```js
Vue.prototype._init = function (options) {
  function initInternalComponent (vm, options) {
    opts._parentVnode = parentVnode;
    opts._renderChildren = vnodeComponentOptions.children;
  }
  initLifecycle(vm);
  initEvents(vm);
  initRender(vm);
  callHook(vm, 'beforeCreate');
  initInjections(vm); // resolve injections before data/props
  initState(vm);
}


function initRender (vm: Component) {
  // ...
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context // 父组件vm做slot的context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
}


/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context //  父组件vm
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) { // 命名slot
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else { // 默认slot
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

```

## scope-slot
### 父组件parse gencode
- 添加属性`el.slotScope = slotScope;`
- 添加属性slotTarget `slot="xxx"`如果有的话
- 在closeElement里除了把节点添加到parent.children中, 还增加scopedSlots属性 `currentParent.scopedSlots[name] = element`
- 父组件内slot的template没有加入vdom树, 而是在获取子组件作用域后就行渲染 ?

```js

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax // 也许slot上绑定东西(*￣︶￣)
  {
    // ...
  }
}

function closeElement (element) {
  if (currentParent && !element.forbidden) {\
      if (element.slotScope) {
        // scoped slot
        // keep it in the children list so that v-else(-if) conditions can
        // find it as the prev node.
        var name = element.slotTarget || '"default"'
        ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
      }
      currentParent.children.push(element);
      element.parent = currentParent;
    }
  }
  element.children = element.children.filter(function (c) { return !(c).slotScope; });
}
```

```js
function genData$2 (el, state) {
  var data = '{';
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component
}
  ```

  ```js
  
function genScopedSlots (
  el,
  slots,
  state
) {
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}
// {
//   scopedSlots: _u([
//     {
//       key: "default",
//       fn: function(props) {
//         return [
//           _c("p", [_v("Hello from parent")]),
//           _c("p", [_v(_s(props.text + props.msg))])
//         ];
//       }
//     }
//   ]);
// }


function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  // "function(props){return [_c('p',[_v("Hello from parent")]),_c('p',[_v(_s(props.text + props.msg))])]}"
  // {key: 'default', fn: xxx}
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

// _c(
//   "div",
//   [
//     _c("child", {
//       scopedSlots: _u([  // L3536 _parentVnode.data.scopedSlots,
//         {
//           key: "default",
//           fn: function(props) {
//             return [
//               _c("p", [_v("Hello from parent")]),
//               _c("p", [_v(_s(props.text + props.msg))])
//             ];
//           }
//         }
//       ])
//     })
//   ],
//   1
// );

```

### 子组件parse gencode render
- 和slot一样, render传入作用域props

```js
function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state); // slot包裹子节点
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs || el.dynamicAttrs // 属性的生成
    ? genProps
}
// with (this) {
//   return _c(
//     "div",
//     { staticClass: "child" },
//     [_t("default", null, { text: "Hello ", msg: msg })],
//     2
//   );
// }

function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}


```


### 父组件运行时/render

```js
function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}
// scopedSlots: {  
//   $stable: true
//   default: renderƒn (props)
// }

Vue.prototype._render = function () { // 子组件render 
  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots( // $scopedSlots 来源
      _parentVnode.data.scopedSlots,
      vm.$slots, // 兼容2.5
      vm.$scopedSlots
    );
  }
}
```

